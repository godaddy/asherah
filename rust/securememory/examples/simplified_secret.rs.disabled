use securememory::mem_sys::{DefaultMemoryManager, MemoryManager, MemoryProtection};
use securememory::secret::{Secret, SecretExtensions};
use std::sync::{Arc, Mutex};
use std::io::{Read, Result as IoResult};

// A simplified implementation of a secure secret
struct SimplifiedSecret {
    // The sensitive data, wrapped in a mutex for thread safety
    data: Mutex<Vec<u8>>,
    // Memory manager for protecting the memory
    memory_manager: Arc<dyn MemoryManager + Send + Sync>,
    // Flag to indicate if the secret has been closed
    closed: Mutex<bool>,
}

impl SimplifiedSecret {
    // Create a new secret with the given data
    fn new(data: &[u8], memory_manager: Arc<dyn MemoryManager + Send + Sync>) -> securememory::error::Result<Self> {
        let mut vec = Vec::with_capacity(data.len());
        vec.extend_from_slice(data);
        
        // Lock the memory to prevent swapping
        memory_manager.lock(&mut vec)?;
        
        // Create the secret
        let secret = Self {
            data: Mutex::new(vec),
            memory_manager,
            closed: Mutex::new(false),
        };
        
        Ok(secret)
    }
}

// Implement the Secret trait for our simplified secret
impl Secret for SimplifiedSecret {
    fn is_closed(&self) -> bool {
        *self.closed.lock().unwrap()
    }
    
    fn close(&self) -> securememory::error::Result<()> {
        let mut closed = self.closed.lock().unwrap();
        if *closed {
            return Ok(());
        }
        
        let mut data = self.data.lock().unwrap();
        
        // Make the memory writable for zeroing
        self.memory_manager.protect(&mut data, MemoryProtection::ReadWrite)?;
        
        // Zero the memory
        for byte in data.iter_mut() {
            *byte = 0;
        }
        
        // Unlock the memory
        self.memory_manager.unlock(&mut data)?;
        
        // Mark as closed
        *closed = true;
        
        Ok(())
    }
    
    fn reader(&self) -> securememory::error::Result<Box<dyn Read + Send + Sync + '_>> {
        if self.is_closed() {
            return Err(securememory::error::SecureMemoryError::SecretClosed);
        }
        
        let data = self.data.lock().unwrap().clone();
        Ok(Box::new(std::io::Cursor::new(data)))
    }
    
    fn len(&self) -> usize {
        self.data.lock().unwrap().len()
    }
}

// Implement a simplified version of SecretExtensions
impl SecretExtensions for SimplifiedSecret {
    fn with_bytes<F, R>(&self, action: F) -> securememory::error::Result<R>
    where
        F: FnOnce(&[u8]) -> securememory::error::Result<R>
    {
        if self.is_closed() {
            return Err(securememory::error::SecureMemoryError::SecretClosed);
        }
        
        let data = self.data.lock().unwrap();
        
        // Call the action with the data
        action(&data)
    }
    
    fn with_bytes_func<F, R>(&self, action: F) -> securememory::error::Result<R>
    where
        F: FnOnce(&[u8]) -> securememory::error::Result<(R, Vec<u8>)>
    {
        if self.is_closed() {
            return Err(securememory::error::SecureMemoryError::SecretClosed);
        }
        
        let data = self.data.lock().unwrap();
        
        // Call the action with the data
        let (result, _new_data) = action(&data)?;
        
        // We ignore the new data in this simplified implementation
        
        Ok(result)
    }
}

// Simple reader implementation for the secret
struct SecretReader<'a> {
    data: &'a [u8],
    position: usize,
}

impl<'a> SecretReader<'a> {
    fn new(data: &'a [u8]) -> Self {
        Self { data, position: 0 }
    }
}

impl<'a> Read for SecretReader<'a> {
    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {
        if self.position >= self.data.len() {
            return Ok(0);
        }
        
        let available = self.data.len() - self.position;
        let to_read = available.min(buf.len());
        
        buf[..to_read].copy_from_slice(&self.data[self.position..self.position + to_read]);
        self.position += to_read;
        
        Ok(to_read)
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Creating memory manager...");
    let memory_manager = Arc::new(DefaultMemoryManager::new());
    println!("Memory manager created successfully");
    
    // Create a secret using our simplified implementation
    println!("Creating simplified secret...");
    let data = b"Test secret data";
    let secret = SimplifiedSecret::new(data, memory_manager.clone())?;
    println!("Secret created successfully with length: {}", secret.len());
    
    // Access the secret data using with_bytes
    println!("Accessing secret data...");
    secret.with_bytes(|bytes| {
        println!("Secret data: {:?}", std::str::from_utf8(bytes).unwrap());
        Ok(())
    })?;
    
    // Close the secret
    println!("Closing secret...");
    secret.close()?;
    println!("Secret closed successfully");
    
    println!("Test completed successfully!");
    Ok(())
}