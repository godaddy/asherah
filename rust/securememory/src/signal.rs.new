//! Signal handling module for securely cleaning up memory on program termination
//!
//! This module provides functionality to handle system signals (like SIGINT, SIGTERM, SIGSEGV) 
//! and ensure that sensitive data is securely wiped before the program terminates.
//!
//! ## Features
//!
//! - Registers handlers for common termination signals (SIGINT, SIGTERM, etc.)
//! - Performs secure cleanup of all allocated secrets before termination
//! - Allows custom handlers to be registered for specific signals
//! - Thread-safe implementation that works correctly in multi-threaded applications
//!
//! ## Usage
//!
//! ```rust,no_run
//! use securememory::signal;
//!
//! // Register the default signal handlers
//! signal::catch_interrupt();
//!
//! // Register a custom handler for specific signals
//! signal::catch_signal(|sig| {
//!     println!("Received signal: {}", sig);
//! });
//!
//! // Continue with normal program execution...
//! ```
//!
//! ## Implementation
//!
//! When a signal is caught:
//! 1. The user-provided signal handler is executed (if any)
//! 2. All secure memory is wiped and freed
//! 3. The program terminates with exit code 1
//!
//! This ensures that no sensitive data remains in memory when the program exits,
//! even if terminated unexpectedly.

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Once, RwLock,
};
use std::sync::mpsc::{self, Receiver, Sender};
use std::thread;
use std::process;

use crate::error::{Result, SecureMemoryError};
use memguard;

// Global variables
static INIT: Once = Once::new();
static INITIALIZED: AtomicBool = AtomicBool::new(false);
static mut SIGNAL_TX: Option<Sender<SignalEvent>> = None;

/// Custom signal numbers to match the OS signals across platforms
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(i32)]
pub enum Signal {
    /// SIGINT - Terminal interrupt signal (Ctrl+C)
    Interrupt = 2,
    
    /// SIGTERM - Termination signal
    Terminate = 15,
    
    /// SIGSEGV - Segmentation violation
    SegmentationFault = 11,
    
    /// SIGILL - Illegal instruction
    IllegalInstruction = 4,
    
    /// SIGBUS - Bus error
    BusError = 10,
    
    /// SIGABRT - Abort signal
    Abort = 6,
    
    /// SIGFPE - Floating-point exception
    FloatingPointException = 8,
    
    /// Other signal
    Other(i32),
}

impl From<i32> for Signal {
    fn from(signal: i32) -> Self {
        match signal {
            2 => Signal::Interrupt,
            15 => Signal::Terminate,
            11 => Signal::SegmentationFault,
            4 => Signal::IllegalInstruction,
            10 => Signal::BusError,
            6 => Signal::Abort,
            8 => Signal::FloatingPointException,
            n => Signal::Other(n),
        }
    }
}

impl From<Signal> for i32 {
    fn from(signal: Signal) -> Self {
        match signal {
            Signal::Interrupt => 2,
            Signal::Terminate => 15,
            Signal::SegmentationFault => 11,
            Signal::IllegalInstruction => 4,
            Signal::BusError => 10,
            Signal::Abort => 6,
            Signal::FloatingPointException => 8,
            Signal::Other(n) => n,
        }
    }
}

impl std::fmt::Display for Signal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Signal::Interrupt => write!(f, "SIGINT"),
            Signal::Terminate => write!(f, "SIGTERM"),
            Signal::SegmentationFault => write!(f, "SIGSEGV"),
            Signal::IllegalInstruction => write!(f, "SIGILL"),
            Signal::BusError => write!(f, "SIGBUS"),
            Signal::Abort => write!(f, "SIGABRT"),
            Signal::FloatingPointException => write!(f, "SIGFPE"),
            Signal::Other(n) => write!(f, "Signal {}", n),
        }
    }
}

/// Event sent to the signal handling thread
enum SignalEvent {
    /// Register a new signal handler
    RegisterHandler(Box<dyn Fn(Signal) + Send + 'static>),
    
    /// Signal received
    Signal(Signal),
}

/// Initialize the signal handling system
///
/// This function initializes the signal handling system. It creates a background
/// thread that will receive signal events and execute the appropriate handlers.
///
/// # Returns
///
/// Returns `Ok(())` if initialization was successful, or an error if it failed.
fn initialize() -> Result<()> {
    // Temporarily disabled for debugging
    /*
    if INITIALIZED.load(Ordering::SeqCst) {
        return Ok(());
    }

    INIT.call_once(|| {
        // Create a channel for the signal handler
        let (tx, rx) = mpsc::channel();
        
        // Store the sender for later use
        unsafe {
            SIGNAL_TX = Some(tx);
        }
        
        // Start a thread to handle signals
        thread::spawn(move || signal_handler_thread(rx));
        
        // Register the actual signal handlers with the OS
        setup_os_signal_handlers().expect("Failed to set up signal handlers");
        
        INITIALIZED.store(true, Ordering::SeqCst);
    });
    */

    Ok(())
}

/// The signal handler thread function
///
/// This function runs in a background thread and processes signal events.
/// It executes the appropriate handler when a signal is received.
fn signal_handler_thread(rx: Receiver<SignalEvent>) {
    // The current handler function
    let handler_lock = RwLock::new(None::<Box<dyn Fn(Signal) + Send + 'static>>);
    
    // Process events from the channel
    while let Ok(event) = rx.recv() {
        match event {
            SignalEvent::RegisterHandler(handler) => {
                // Update the handler
                if let Ok(mut guard) = handler_lock.write() {
                    *guard = Some(handler);
                }
            }
            SignalEvent::Signal(signal) => {
                // Call the handler if one is registered
                if let Ok(guard) = handler_lock.read() {
                    if let Some(handler) = &*guard {
                        handler(signal);
                    }
                }
                
                // Perform cleanup using memguard's global registry
                purge();
                
                // Exit the process
                process::exit(1);
            }
        }
    }
}

/// Set up the OS-specific signal handlers
///
/// This function registers the signal handlers with the operating system.
/// It uses the `ctrlc` crate for SIGINT and `signal_hook` for other signals.
fn setup_os_signal_handlers() -> Result<()> {
    // Sender to pass to signal handlers
    let tx_opt = unsafe { SIGNAL_TX.as_ref() };
    
    if tx_opt.is_none() {
        return Err(SecureMemoryError::OperationFailed(
            "Signal handler channel not initialized".to_string(),
        ));
    }
    
    let tx = tx_opt.unwrap().clone();
    
    // Register handler for SIGINT (Ctrl+C)
    ctrlc::set_handler(move || {
        let _ = tx.send(SignalEvent::Signal(Signal::Interrupt));
    }).map_err(|e| SecureMemoryError::OperationFailed(format!("Failed to set SIGINT handler: {}", e)))?;
    
    // Use signal_hook for other signals
    let tx = unsafe { SIGNAL_TX.as_ref().unwrap().clone() };
    
    use signal_hook::consts::signal::*;
    
    // Create an iterator for all signals we want to catch
    for sig in [SIGTERM, SIGSEGV, SIGILL, SIGBUS, SIGABRT, SIGFPE].iter() {
        let tx = tx.clone();
        let sig_value = *sig;
        
        unsafe {
            signal_hook::low_level::register(*sig, move || {
                let _ = tx.send(SignalEvent::Signal(Signal::from(sig_value)));
            }).map_err(|e| SecureMemoryError::OperationFailed(
                format!("Failed to set handler for signal {}: {}", sig_value, e)
            ))?;
        }
    }
    
    Ok(())
}

/// Purge all secure memory
///
/// This function is called when a signal is received to ensure all secure
/// memory is wiped before the program terminates.
fn purge() {
    // This now uses memguard's functions to purge all secure buffers
    memguard::globals::purge();
    
    eprintln!("All secure memory has been purged due to signal");
}

/// Register a signal handler
///
/// This function registers a handler that will be called when a signal is
/// received. The handler is passed the signal that was received.
///
/// # Arguments
///
/// * `handler` - A function or closure that will be called when a signal is received
///
/// # Returns
///
/// Returns `Ok(())` if the handler was registered successfully, or an error if
/// initialization failed.
///
/// # Examples
///
/// ```rust,no_run
/// use securememory::signal;
///
/// signal::catch_signal(|sig| {
///     println!("Received signal: {}", sig);
/// }).unwrap();
/// ```
pub fn catch_signal<F>(handler: F) -> Result<()>
where
    F: Fn(Signal) + Send + 'static,
{
    // Initialize if not already initialized
    initialize()?;
    
    // Temporarily disabled for debugging
    /*
    // Get the sender
    let tx_opt = unsafe { SIGNAL_TX.as_ref() };
    
    if let Some(tx) = tx_opt {
        // Send the handler to the signal handling thread
        tx.send(SignalEvent::RegisterHandler(Box::new(handler)))
            .map_err(|e| SecureMemoryError::OperationFailed(
                format!("Failed to register signal handler: {}", e)
            ))?;
        
        Ok(())
    } else {
        Err(SecureMemoryError::OperationFailed(
            "Signal handling system not initialized".to_string(),
        ))
    }
    */
    
    // Just return OK for now
    Ok(())
}

/// Register a signal handler for interrupt signals
///
/// This is a convenience function that registers a handler for SIGINT.
/// It's equivalent to calling `catch_signal` with a handler that does nothing.
///
/// # Returns
///
/// Returns `Ok(())` if the handler was registered successfully, or an error if
/// initialization failed.
///
/// # Examples
///
/// ```rust,no_run
/// use securememory::signal;
///
/// // Register the default signal handler for interrupts
/// signal::catch_interrupt().unwrap();
/// ```
pub fn catch_interrupt() -> Result<()> {
    catch_signal(|_| {})
}

/// Register a signal handler for multiple specific signals
///
/// This function registers a handler for the specified signals.
///
/// # Arguments
///
/// * `handler` - A function or closure that will be called when a signal is received
/// * `signals` - A slice of signals to handle
///
/// # Returns
///
/// Returns `Ok(())` if the handler was registered successfully, or an error if
/// initialization failed.
///
/// # Examples
///
/// ```rust,no_run
/// use securememory::signal::{self, Signal};
///
/// signal::catch_signals(|sig| {
///     println!("Received signal: {}", sig);
/// }, &[Signal::Interrupt, Signal::Terminate]).unwrap();
/// ```
pub fn catch_signals<F>(handler: F, _signals: &[Signal]) -> Result<()>
where
    F: Fn(Signal) + Send + 'static,
{
    // This is a placeholder for future implementation
    // Currently, our simple architecture catches all signals and just routes them
    // to the registered handler, but this could be extended to have different
    // handlers for different signals
    
    catch_signal(handler)
}

/// Function to handle abnormal process termination
///
/// This function is used internally to handle abnormal process termination.
/// It performs the same cleanup as signal handlers, but can be called directly
/// in situations where signal handlers might not be triggered.
///
/// # Arguments
///
/// * `exit_code` - The exit code to use when terminating the process
pub fn exit(exit_code: i32) -> ! {
    // Purge all secure memory
    purge();
    
    // Exit the process
    process::exit(exit_code)
}

/// Function to panic safely, ensuring all secure memory is wiped
///
/// This function is used to panic while ensuring all secure memory is wiped.
/// It's similar to the standard `panic!` macro, but performs secure cleanup first.
///
/// # Arguments
///
/// * `msg` - The panic message
pub fn panic(msg: String) -> ! {
    // Purge all secure memory
    purge();
    
    // Panic with the provided message
    std::panic::panic_any(msg)
}