use crate::error::Result;
use crate::protected_memory::secret::ProtectedMemorySecret;
use crate::secret::{Secret, SecretFactory};
use memguard::Buffer;
use std::sync::Arc;
use std::time::Instant;
use subtle::ConstantTimeEq;
use zeroize::Zeroize;

/// Default implementation of SecretFactory that produces ProtectedMemorySecret instances.
///
/// This factory uses the platform's memory protection features to create
/// secrets that are securely stored in memory, protected from observation
/// and tampering.
///
/// # Example
///
/// ```rust,no_run
/// # use securememory::secret::SecretFactory;
/// # use securememory::protected_memory::DefaultSecretFactory;
/// #
/// // Create a factory
/// let factory = DefaultSecretFactory::new();
///
/// // Create a secret from a password
/// let mut password = b"secure-password-123".to_vec();
/// let secret = factory.new(&mut password).unwrap();
///
/// // Password data is now wiped from the original slice
/// assert_ne!(password, b"secure-password-123");
/// ```
#[derive(Clone)]
pub struct DefaultSecretFactory {
    /// Optional custom buffer provider for testing
    #[cfg(test)]
    test_buffer_provider: Option<Arc<dyn Fn(usize) -> Result<Buffer> + Send + Sync>>,
}

impl DefaultSecretFactory {
    /// Creates a new DefaultSecretFactory.
    ///
    /// # Returns
    ///
    /// A new DefaultSecretFactory instance
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use securememory::protected_memory::DefaultSecretFactory;
    /// #
    /// let factory = DefaultSecretFactory::new();
    /// ```
    pub fn new() -> Self {
        Self {
            #[cfg(test)]
            test_buffer_provider: None,
        }
    }

    /// Creates a test-specific factory with a custom buffer provider.
    /// This is only available in test builds and is useful for testing
    /// different memory allocation scenarios.
    #[cfg(test)]
    pub fn with_test_buffer_provider(
        provider: Arc<dyn Fn(usize) -> Result<Buffer> + Send + Sync>,
    ) -> Self {
        Self {
            test_buffer_provider: Some(provider),
        }
    }

    /// Creates a new buffer with the given size, using the test provider if available
    #[cfg(test)]
    fn create_buffer(&self, size: usize) -> Result<Buffer> {
        match &self.test_buffer_provider {
            Some(provider) => provider(size),
            None => Buffer::new(size),
        }
    }

    /// Creates a new buffer with the given size
    #[cfg(not(test))]
    fn create_buffer(&self, size: usize) -> Result<Buffer> {
        Buffer::new(size)
    }
}

impl Default for DefaultSecretFactory {
    fn default() -> Self {
        Self::new()
    }
}

impl SecretFactory for DefaultSecretFactory {
    type SecretType = ProtectedMemorySecret;
    
    /// Creates a new Secret from the provided byte array.
    ///
    /// This method securely copies the data from the input array to a new
    /// Secret instance. The input array is zeroed out to protect the original
    /// sensitive data. The copying is done in constant time to avoid timing
    /// attacks.
    ///
    /// # Arguments
    ///
    /// * `b` - A mutable byte slice containing the data to store in the Secret
    ///
    /// # Returns
    ///
    /// A new Secret instance containing the data
    ///
    /// # Errors
    ///
    /// Returns an error if memory allocation or protection fails, or if the
    /// input array is empty.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use securememory::secret::SecretFactory;
    /// # use securememory::protected_memory::DefaultSecretFactory;
    /// #
    /// let factory = DefaultSecretFactory::new();
    ///
    /// // Create a secret from a password
    /// let mut password = b"secure-password-123".to_vec();
    /// let secret = factory.new(&mut password).unwrap();
    ///
    /// // Password data is now wiped from the original slice
    /// assert_ne!(password, b"secure-password-123");
    /// ```
    fn new(&self, b: &mut [u8]) -> Result<Self::SecretType> {
        #[cfg(feature = "metrics")]
        let start = Instant::now();
        #[cfg(not(feature = "metrics"))]
        let _start = Instant::now(); // Used for debugging, prefixed with _ to avoid warning

        if b.is_empty() {
            return Err(crate::error::SecureMemoryError::OperationFailed(
                "Cannot create a secret from an empty byte slice".to_string(),
            ));
        }

        // Create a buffer with the required size
        let mut buffer = self.create_buffer(b.len())?;

        // Copy the data into the buffer in constant time
        buffer.with_data_mut(|dest| {
            if dest.ct_eq(b).into() {
                // If the buffers are already equal, no need to copy
                // (this is just a safety check)
            } else {
                // Copy bytes in constant time to avoid timing attacks
                for (dst, src) in dest.iter_mut().zip(b.iter()) {
                    *dst = *src;
                }
            }
            Ok(())
        })?;

        // Wipe the source array
        b.zeroize();

        // Create the protected memory secret
        let secret = ProtectedMemorySecret::new(buffer)?;

        // Record timing metric
        #[cfg(feature = "metrics")]
        metrics::histogram!("secret.protectedmemory.alloc_duration_seconds").record(start.elapsed().as_secs_f64());

        Ok(secret)
    }

    /// Creates a Secret containing random bytes of the specified size.
    ///
    /// This method allocates a new Secret instance and fills it with
    /// cryptographically secure random bytes.
    ///
    /// # Arguments
    ///
    /// * `size` - The number of random bytes to generate
    ///
    /// # Returns
    ///
    /// A new Secret instance containing random bytes
    ///
    /// # Errors
    ///
    /// Returns an error if memory allocation or protection fails, or if
    /// random number generation fails.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use securememory::secret::SecretFactory;
    /// # use securememory::protected_memory::DefaultSecretFactory;
    /// #
    /// let factory = DefaultSecretFactory::new();
    ///
    /// // Create a random secret with 32 bytes (e.g., for an AES-256 key)
    /// let secret = factory.create_random(32).unwrap();
    /// ```
    fn create_random(&self, size: usize) -> Result<Self::SecretType> {
        #[cfg(feature = "metrics")]
        let start = Instant::now();
        #[cfg(not(feature = "metrics"))]
        let _start = Instant::now(); // Used for debugging, prefixed with _ to avoid warning

        if size == 0 {
            return Err(crate::error::SecureMemoryError::OperationFailed(
                "Cannot create a random secret with zero size".to_string(),
            ));
        }

        // Create a buffer with the required size
        let mut buffer = self.create_buffer(size)?;

        // Fill the buffer with random data
        let mut buf = vec![0u8; size];
        getrandom::getrandom(&mut buf).map_err(|e| {
            crate::error::SecureMemoryError::RandomGenerationFailed(format!("{}", e))
        })?;

        buffer.with_data_mut(|data| {
            data.copy_from_slice(&buf);
            Ok(())
        })?;

        // Zero out the temporary buffer
        buf.zeroize();

        // Create the protected memory secret
        let secret = ProtectedMemorySecret::new(buffer)?;

        // Record timing metric
        #[cfg(feature = "metrics")]
        metrics::histogram!("secret.protectedmemory.alloc_duration_seconds").record(start.elapsed().as_secs_f64());

        Ok(secret)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::error::SecureMemoryError;
    use crate::secret::{Secret, SecretExtensions};
    
    #[test]
    fn test_new_secret() {
        let factory = DefaultSecretFactory::new();
        let mut data = b"test_secret_data".to_vec();
        let secret = factory.new(&mut data).unwrap();
        
        // Verify original data was wiped
        assert_ne!(data, b"test_secret_data");
        
        // Verify secret contains the expected data
        secret.with_bytes(|bytes| {
            assert_eq!(bytes, b"test_secret_data");
            Ok(())
        }).unwrap();
    }
    
    #[test]
    fn test_empty_slice() {
        let factory = DefaultSecretFactory::new();
        let mut empty = Vec::<u8>::new();
        let result = factory.new(&mut empty);
        
        assert!(matches!(
            result,
            Err(SecureMemoryError::OperationFailed(_))
        ));
    }
    
    #[test]
    fn test_create_random() {
        let factory = DefaultSecretFactory::new();
        let size = 32;
        let secret = factory.create_random(size).unwrap();
        
        secret.with_bytes(|bytes| {
            // Verify size
            assert_eq!(bytes.len(), size);
            
            // Verify it's not all zeros
            let all_zeros = bytes.iter().all(|&b| b == 0);
            assert!(!all_zeros, "Random data shouldn't be all zeros");
            
            Ok(())
        }).unwrap();
    }
    
    #[test]
    fn test_zero_size_random() {
        let factory = DefaultSecretFactory::new();
        let result = factory.create_random(0);
        
        assert!(matches!(
            result,
            Err(SecureMemoryError::OperationFailed(_))
        ));
    }
    
    #[test]
    fn test_clone_and_drop() {
        let factory = DefaultSecretFactory::new();
        let mut data = b"test_clone".to_vec();
        let secret = factory.new(&mut data).unwrap();
        
        // Clone the secret
        let secret_clone = secret.clone();
        
        // Verify both have the same data
        secret.with_bytes(|bytes| {
            assert_eq!(bytes, b"test_clone");
            Ok(())
        }).unwrap();
        
        secret_clone.with_bytes(|bytes| {
            assert_eq!(bytes, b"test_clone");
            Ok(())
        }).unwrap();
        
        // Drop the original
        drop(secret);
        
        // Verify clone still works
        secret_clone.with_bytes(|bytes| {
            assert_eq!(bytes, b"test_clone");
            Ok(())
        }).unwrap();
    }
    
    #[test]
    fn test_close() {
        let factory = DefaultSecretFactory::new();
        let mut data = b"test_close".to_vec();
        let secret = factory.new(&mut data).unwrap();
        
        // Close the secret
        secret.close().unwrap();
        
        // Verify it's closed
        assert!(secret.is_closed());
        
        // Verify it can't be accessed
        let result = secret.with_bytes(|_| Ok(()));
        assert!(matches!(result, Err(SecureMemoryError::SecretClosed)));
    }
}