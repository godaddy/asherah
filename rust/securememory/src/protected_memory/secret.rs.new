use crate::error::{Result, SecureMemoryError};
use crate::secret::{Secret, SecretExtensions};
use log::{debug, trace};
use memguard::Buffer;
use std::fmt;
use std::io::Read;
use std::sync::{Arc, Mutex};

/// A secret implementation that uses protected memory to store sensitive data.
///
/// This implementation uses the memguard library's Buffer type to store
/// secret data with enhanced memory protection:
///
/// - Memory is protected from access when not in use (NoAccess)
/// - Memory is locked to prevent swapping to disk
/// - Memory is securely wiped when the secret is closed
/// - Access to the data is controlled through with_bytes functions
/// - The implementation is thread-safe and can be shared across threads
///
/// # Example
///
/// ```rust,no_run
/// use securememory::protected_memory::DefaultSecretFactory;
/// use securememory::secret::{Secret, SecretExtensions, SecretFactory};
///
/// // Create a factory
/// let factory = DefaultSecretFactory::new();
///
/// // Create a secret
/// let mut data = b"sensitive-data".to_vec();
/// let secret = factory.new(&mut data).unwrap();
///
/// // Access the secret
/// secret.with_bytes(|bytes| {
///     assert_eq!(bytes, b"sensitive-data");
///     Ok(())
/// }).unwrap();
///
/// // Close the secret when done
/// secret.close().unwrap();
/// ```
pub struct ProtectedMemorySecret {
    /// The memguard buffer that stores the secret data
    ///
    /// Wrapped in a mutex for thread safety, and an Arc for cloning/sharing
    inner: Arc<Mutex<ProtectedMemorySecretState>>,
}

/// Inner state of the protected memory secret
struct ProtectedMemorySecretState {
    /// The buffer containing the secret data
    buffer: Option<Buffer>,
    
    /// Flag indicating if the secret has been closed
    closed: bool,
    
    /// Debug backtrace for tracking secret creation
    #[cfg(feature = "debug_backtrace")]
    backtrace: Option<backtrace::Backtrace>,
}

impl ProtectedMemorySecret {
    /// Creates a new ProtectedMemorySecret.
    ///
    /// # Arguments
    ///
    /// * `buffer` - A memguard Buffer containing the secret data
    ///
    /// # Returns
    ///
    /// * `Result<Self>` - A new ProtectedMemorySecret instance
    ///
    /// # Errors
    ///
    /// * `SecureMemoryError::OperationFailed` - If an error occurs during creation
    pub fn new(buffer: Buffer) -> Result<Self> {
        let len = buffer.size();
        trace!("Created new protected memory secret of {} bytes", len);
        
        #[cfg(feature = "metrics")]
        metrics::counter!("securememory.in_use_counter").increment(1);
        
        // Create the inner state
        let state = ProtectedMemorySecretState {
            buffer: Some(buffer),
            closed: false,
            #[cfg(feature = "debug_backtrace")]
            backtrace: if log::log_enabled!(log::Level::Debug) {
                Some(backtrace::Backtrace::new_unresolved())
            } else {
                None
            },
        };
        
        Ok(Self {
            inner: Arc::new(Mutex::new(state)),
        })
    }
}

impl Clone for ProtectedMemorySecret {
    fn clone(&self) -> Self {
        Self {
            inner: Arc::clone(&self.inner),
        }
    }
}

impl Secret for ProtectedMemorySecret {
    fn is_closed(&self) -> bool {
        let state = self.inner.lock().unwrap();
        state.closed
    }
    
    fn close(&self) -> Result<()> {
        let mut state = self.inner.lock().unwrap();
        
        // Check if already closed
        if state.closed {
            return Ok(());
        }
        
        // Take the buffer out of the state
        if let Some(buffer) = state.buffer.take() {
            // Destroy the buffer to wipe and free memory
            buffer.destroy()?;
        }
        
        // Mark as closed
        state.closed = true;
        
        // Decrement the in-use counter
        #[cfg(feature = "metrics")]
        metrics::counter!("securememory.in_use_counter").decrement(1);
        
        trace!("Secret closed");
        Ok(())
    }
    
    fn reader(&self) -> Result<Box<dyn Read + Send + Sync + '_>> {
        // Check if closed
        let state = self.inner.lock().unwrap();
        if state.closed {
            return Err(SecureMemoryError::SecretClosed);
        }
        
        // Drop the lock so we don't hold it
        drop(state);
        
        Ok(Box::new(crate::secret::SecretReader::new(self)))
    }
    
    fn len(&self) -> usize {
        let state = self.inner.lock().unwrap();
        match &state.buffer {
            Some(buffer) => buffer.size(),
            None => 0,
        }
    }
}

impl SecretExtensions for ProtectedMemorySecret {
    fn with_bytes<F, R>(&self, action: F) -> Result<R>
    where
        F: FnOnce(&[u8]) -> Result<R>,
    {
        // Get a lock on the state
        let state = self.inner.lock().unwrap();
        
        // Check if closed
        if state.closed {
            return Err(SecureMemoryError::SecretClosed);
        }
        
        // Get a reference to the buffer
        match &state.buffer {
            Some(buffer) => {
                // Call buffer.with_data to apply the action
                // This automatically handles memory protection
                buffer.with_data(|data| action(data))
            },
            None => Err(SecureMemoryError::SecretClosed),
        }
    }
    
    fn with_bytes_func<F, R>(&self, action: F) -> Result<R>
    where
        F: FnOnce(&[u8]) -> Result<(R, Vec<u8>)>,
    {
        // For this implementation, we ignore the returned byte array
        // since we don't allow modifying the secret after creation
        // We just pass through the result value
        self.with_bytes(|data| {
            let (result, _) = action(data)?;
            Ok(result)
        })
    }
}

impl Drop for ProtectedMemorySecret {
    fn drop(&mut self) {
        if let Err(e) = self.close() {
            debug!("Error closing secret in drop: {:?}", e);
            #[cfg(feature = "debug_backtrace")]
            if let Ok(state) = self.inner.lock() {
                if let Some(backtrace) = &state.backtrace {
                    debug!("Secret created at: {:?}", backtrace);
                }
            }
        }
    }
}

impl fmt::Debug for ProtectedMemorySecret {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let state = self.inner.lock().unwrap();
        let len = match &state.buffer {
            Some(buffer) => buffer.size(),
            None => 0,
        };
        
        write!(
            f,
            "ProtectedMemorySecret {{ len: {}, closed: {} }}",
            len,
            state.closed
        )
    }
}