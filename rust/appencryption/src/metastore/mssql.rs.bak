use crate::envelope::EnvelopeKeyRecord;
use crate::error::{Error, Result};
use crate::Metastore;

use async_trait::async_trait;
use chrono::{DateTime, TimeZone, Utc};
use metrics::timer;
use sqlx::{Mssql, MssqlPool};
use std::sync::Arc;
use std::time::Instant;

// SQL Server uses @p1, @p2, etc. for parameters
const LOAD_KEY_QUERY: &str = "SELECT key_record FROM encryption_key WHERE id = @p1 AND created = @p2";
const STORE_KEY_QUERY: &str = "INSERT INTO encryption_key (id, created, key_record) VALUES (@p1, @p2, @p3)";
const LOAD_LATEST_QUERY: &str = "SELECT TOP 1 key_record FROM encryption_key WHERE id = @p1 ORDER BY created DESC";

/// SQL Server metastore implementation
pub struct MssqlMetastore {
    /// Connection pool for SQL Server
    pool: Arc<MssqlPool>,
}

impl MssqlMetastore {
    /// Creates a new SQL Server metastore with the given connection pool
    pub fn new(pool: Arc<MssqlPool>) -> Self {
        Self { pool }
    }

    /// Parses an envelope key record from a JSON string
    fn parse_envelope(json_str: &str) -> Result<EnvelopeKeyRecord> {
        serde_json::from_str(json_str)
            .map_err(|e| Error::Metastore(format!("Unable to parse key: {}", e)))
    }
}

#[async_trait]
impl Metastore for MssqlMetastore {
    async fn load(&self, id: &str, created: i64) -> Result<Option<EnvelopeKeyRecord>> {
        let timer = timer!("ael.metastore.mssql.load");
        
        let created_dt = Utc.timestamp_opt(created, 0)
            .single()
            .ok_or_else(|| Error::Metastore("Invalid timestamp".to_string()))?;
            
        let result = sqlx::query_as::<Mssql, (String,)>(LOAD_KEY_QUERY)
            .bind(id)
            .bind(created_dt)
            .fetch_optional(&*self.pool)
            .await
            .map_err(|e| Error::Metastore(format!("Error loading key: {}", e)))?;
        
        match result {
            Some((json_str,)) => {
                let envelope = Self::parse_envelope(&json_str)?;
                Ok(Some(envelope))
            }
            None => Ok(None),
        }
    }
    
    async fn load_latest(&self, id: &str) -> Result<Option<EnvelopeKeyRecord>> {
        let timer = timer!("ael.metastore.mssql.loadlatest");
        
        let result = sqlx::query_as::<Mssql, (String,)>(LOAD_LATEST_QUERY)
            .bind(id)
            .fetch_optional(&*self.pool)
            .await
            .map_err(|e| Error::Metastore(format!("Error loading latest key: {}", e)))?;
        
        match result {
            Some((json_str,)) => {
                let envelope = Self::parse_envelope(&json_str)?;
                Ok(Some(envelope))
            }
            None => Ok(None),
        }
    }
    
    async fn store(&self, id: &str, created: i64, envelope: &EnvelopeKeyRecord) -> Result<bool> {
        let timer = timer!("ael.metastore.mssql.store");
        
        let created_dt = Utc.timestamp_opt(created, 0)
            .single()
            .ok_or_else(|| Error::Metastore("Invalid timestamp".to_string()))?;
            
        let json_str = serde_json::to_string(envelope)
            .map_err(|e| Error::Metastore(format!("Failed to serialize key: {}", e)))?;
            
        let result = sqlx::query(STORE_KEY_QUERY)
            .bind(id)
            .bind(created_dt)
            .bind(json_str)
            .execute(&*self.pool)
            .await;
            
        match result {
            Ok(query_result) => Ok(query_result.rows_affected() > 0),
            Err(e) => {
                // Handle duplicate key errors gracefully
                let error_string = e.to_string();
                if error_string.contains("duplicate") || 
                   error_string.contains("UNIQUE") ||
                   error_string.contains("Violation of PRIMARY KEY") {
                    Ok(false)
                } else {
                    Err(Error::Metastore(format!("Error storing key: {}", e)))
                }
            }
        }
    }
}